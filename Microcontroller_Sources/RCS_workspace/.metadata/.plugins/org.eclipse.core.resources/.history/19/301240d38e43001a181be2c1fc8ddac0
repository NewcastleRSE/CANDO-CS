/* ###################################################################
**     Filename    : Phase_Shift_Algorithm.c
**     Project     : RCS_Box_2.1
**     Processor   : MK22FN512VDC12
**     Component   : Events
**     Version     : Driver 01.00
**     Compiler    : GNU C Compiler
**     Date/Time   : 2020-01-29, 16:48, # CodeGen: 0
**     Abstract    :
**         	Contains function definitions related to the phase shift
**         	algorithms.
** ###################################################################*/

#include "Phase_Shift_Algorithm.h"
#include "arm_math.h"

unsigned char algorithm = ORIGINAL;

float kernel[PHASE_CONDS][NO_OF_TAPS] = {0.0f};
float conv_reg[NO_OF_TAPS] = {0.0f};

float fai = 0.0f;
float alpha = 1.25f;
unsigned short threshold = 0*10;
unsigned char phase_cond = 0;
unsigned short f = 10;

float convIntFloat(unsigned int i)
{
	float f;

	f = i/255.0f*2.0f;

	f -= 1.0f;

	return f;
}

unsigned int convFloatInt(float f)
{
	unsigned int i;

	i = (f+120.0f)*0.5f;

	return i;
}

void init_kernel(void)
{
	unsigned short taps_index = 0;

	float total = 0.0f, max = 0.0f;

	for(phase_cond = 0; phase_cond < PHASE_CONDS; phase_cond++)
	{
		fai = phase_cond*45.0f/180.0f;
		fai = fai*3.14f;

		total = 0.0f;

		for(taps_index = 0; taps_index < NO_OF_TAPS; taps_index++)
		{
			kernel[phase_cond][taps_index] = exp(-alpha*f*(0.002f*taps_index))*cos(2.0f*3.14f*f*taps_index*0.002f-fai);
			total += kernel[phase_cond][taps_index];
		}

		total = total / 120.0f;

		for(taps_index = 0; taps_index < NO_OF_TAPS; taps_index++)
		{
			kernel[phase_cond][taps_index] -= total;
		}
	}

	phase_cond = 0;
}

void phase_shift(unsigned short *rec_reg_ptr, unsigned short *stim_reg_ptr)
{
	float rconv = 0.0f;
	unsigned short j, i;
	unsigned char scale = 1;

	conv_reg[NO_OF_TAPS - 1] = convIntFloat(*rec_reg_ptr);

	for(j = 0; j < NO_OF_TAPS; j++)
	{
		rconv = kernel[phase_cond][j] * conv_reg[NO_OF_TAPS - 1 - j] + rconv;
	}

	rconv /= 120.0f;

	*stim_reg_ptr = convFloatInt(rconv) * scale;             // Outputs scaling to fit DAC

	if(*stim_reg_ptr > threshold)                          	// Set intensity process
	{
		if (algorithm == SET_INTENSITY)
			*stim_reg_ptr = scale * 400;                     // Set output as the maximum value

		if (*stim_reg_ptr >= 4000)
		{
			*stim_reg_ptr = 4000;
		}
	}
	else
	{
		*stim_reg_ptr = 0;
	}

	for(i = 0; i < (NO_OF_TAPS - 1); i++)
	{
		conv_reg[i] = conv_reg[i + 1];
	}
}

